{"version":3,"sources":["assets\\Script\\Encrypt\\lib\\jsbn\\rng.js"],"names":["rng_state","rng_pool","rng_pptr","t","window","crypto","getRandomValues","z","Uint32Array","length","count","onMouseMoveListener_1","ev","rng_psize","removeEventListener","detachEvent","mouseCoordinates","x","y","e","addEventListener","attachEvent","rng_get_byte","random","Math","floor","init","next","SecureRandom","prototype","nextBytes","ba","i"],"mappings":"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","sourceRoot":"/","sourcesContent":["// Random number generator - requires a PRNG backend, e.g. prng4.js\nimport { prng_newstate, rng_psize } from \"./prng4\";\nvar rng_state;\nvar rng_pool = null;\nvar rng_pptr;\n// Initialize the pool with junk if needed.\nif (rng_pool == null) {\n    rng_pool = [];\n    rng_pptr = 0;\n    var t = void 0;\n    if (window.crypto && window.crypto.getRandomValues) {\n        // Extract entropy (2048 bits) from RNG if available\n        var z = new Uint32Array(256);\n        window.crypto.getRandomValues(z);\n        for (t = 0; t < z.length; ++t) {\n            rng_pool[rng_pptr++] = z[t] & 255;\n        }\n    }\n    // Use mouse events for entropy, if we do not have enough entropy by the time\n    // we need it, entropy will be generated by Math.random.\n    var count = 0;\n    var onMouseMoveListener_1 = function (ev) {\n        count = count || 0;\n        if (count >= 256 || rng_pptr >= rng_psize) {\n            if (window.removeEventListener) {\n                window.removeEventListener(\"mousemove\", onMouseMoveListener_1, false);\n            }\n            else if (window.detachEvent) {\n                window.detachEvent(\"onmousemove\", onMouseMoveListener_1);\n            }\n            return;\n        }\n        try {\n            var mouseCoordinates = ev.x + ev.y;\n            rng_pool[rng_pptr++] = mouseCoordinates & 255;\n            count += 1;\n        }\n        catch (e) {\n            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n        }\n    };\n    if (window.addEventListener) {\n        window.addEventListener(\"mousemove\", onMouseMoveListener_1, false);\n    }\n    else if (window.attachEvent) {\n        window.attachEvent(\"onmousemove\", onMouseMoveListener_1);\n    }\n}\nfunction rng_get_byte() {\n    if (rng_state == null) {\n        rng_state = prng_newstate();\n        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random\n        while (rng_pptr < rng_psize) {\n            var random = Math.floor(65536 * Math.random());\n            rng_pool[rng_pptr++] = random & 255;\n        }\n        rng_state.init(rng_pool);\n        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\n            rng_pool[rng_pptr] = 0;\n        }\n        rng_pptr = 0;\n    }\n    // TODO: allow reseeding after first request\n    return rng_state.next();\n}\nvar SecureRandom = /** @class */ (function () {\n    function SecureRandom() {\n    }\n    SecureRandom.prototype.nextBytes = function (ba) {\n        for (var i = 0; i < ba.length; ++i) {\n            ba[i] = rng_get_byte();\n        }\n    };\n    return SecureRandom;\n}());\nexport { SecureRandom };\n"]}