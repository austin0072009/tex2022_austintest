{
  "__type__": "cc.TextAsset",
  "_name": "jsbn.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { SecureRandom } from \"./rng\";\nexport declare class BigInteger {\n    constructor(a: number | number[] | string, b?: number | SecureRandom, c?: number | SecureRandom);\n    toString(b: number): string;\n    protected negate(): BigInteger;\n    abs(): BigInteger;\n    compareTo(a: BigInteger): number;\n    bitLength(): number;\n    mod(a: BigInteger): BigInteger;\n    modPowInt(e: number, m: BigInteger): BigInteger;\n    protected clone(): BigInteger;\n    protected intValue(): number;\n    protected byteValue(): number;\n    protected shortValue(): number;\n    protected signum(): 0 | 1 | -1;\n    toByteArray(): number[];\n    protected equals(a: BigInteger): boolean;\n    protected min(a: BigInteger): BigInteger;\n    protected max(a: BigInteger): BigInteger;\n    protected and(a: BigInteger): BigInteger;\n    protected or(a: BigInteger): BigInteger;\n    protected xor(a: BigInteger): BigInteger;\n    protected andNot(a: BigInteger): BigInteger;\n    protected not(): BigInteger;\n    protected shiftLeft(n: number): BigInteger;\n    protected shiftRight(n: number): BigInteger;\n    protected getLowestSetBit(): number;\n    protected bitCount(): number;\n    protected testBit(n: number): boolean;\n    protected setBit(n: number): BigInteger;\n    protected clearBit(n: number): BigInteger;\n    protected flipBit(n: number): BigInteger;\n    add(a: BigInteger): BigInteger;\n    subtract(a: BigInteger): BigInteger;\n    multiply(a: BigInteger): BigInteger;\n    divide(a: BigInteger): BigInteger;\n    protected remainder(a: BigInteger): BigInteger;\n    protected divideAndRemainder(a: BigInteger): BigInteger[];\n    modPow(e: BigInteger, m: BigInteger): BigInteger;\n    modInverse(m: BigInteger): BigInteger;\n    protected pow(e: number): BigInteger;\n    gcd(a: BigInteger): BigInteger;\n    isProbablePrime(t: number): boolean;\n    copyTo(r: BigInteger): void;\n    fromInt(x: number): void;\n    protected fromString(s: string | number[], b: number): void;\n    clamp(): void;\n    dlShiftTo(n: number, r: BigInteger): void;\n    drShiftTo(n: number, r: BigInteger): void;\n    protected lShiftTo(n: number, r: BigInteger): void;\n    protected rShiftTo(n: number, r: BigInteger): void;\n    subTo(a: BigInteger, r: BigInteger): void;\n    multiplyTo(a: BigInteger, r: BigInteger): void;\n    squareTo(r: BigInteger): void;\n    divRemTo(m: BigInteger, q: BigInteger, r: BigInteger): void;\n    invDigit(): number;\n    protected isEven(): boolean;\n    protected exp(e: number, z: IReduction): BigInteger;\n    protected chunkSize(r: number): number;\n    protected toRadix(b: number): string;\n    fromRadix(s: string, b: number): void;\n    protected fromNumber(a: number, b: number | SecureRandom, c?: number | SecureRandom): void;\n    protected bitwiseTo(a: BigInteger, op: (a: number, b: number) => number, r: BigInteger): void;\n    protected changeBit(n: number, op: (a: number, b: number) => number): BigInteger;\n    protected addTo(a: BigInteger, r: BigInteger): void;\n    protected dMultiply(n: number): void;\n    dAddOffset(n: number, w: number): void;\n    multiplyLowerTo(a: BigInteger, n: number, r: BigInteger): void;\n    multiplyUpperTo(a: BigInteger, n: number, r: BigInteger): void;\n    protected modInt(n: number): number;\n    protected millerRabin(t: number): boolean;\n    protected square(): BigInteger;\n    gcda(a: BigInteger, callback: (x: BigInteger) => void): void;\n    fromNumberAsync(a: number, b: number | SecureRandom, c: number | SecureRandom, callback: () => void): void;\n    s: number;\n    t: number;\n    DB: number;\n    DM: number;\n    DV: number;\n    FV: number;\n    F1: number;\n    F2: number;\n    am: (i: number, x: number, w: BigInteger, j: number, c: number, n: number) => number;\n    [index: number]: number;\n    static ONE: BigInteger;\n    static ZERO: BigInteger;\n}\nexport interface IReduction {\n    convert(x: BigInteger): BigInteger;\n    revert(x: BigInteger): BigInteger;\n    mulTo(x: BigInteger, y: BigInteger, r: BigInteger): void;\n    sqrTo(x: BigInteger, r: BigInteger): void;\n}\nexport declare function nbi(): BigInteger;\nexport declare function parseBigInt(str: string, r: number): BigInteger;\nexport declare function intAt(s: string, i: number): number;\nexport declare function nbv(i: number): BigInteger;\nexport declare function nbits(x: number): number;\n"
}